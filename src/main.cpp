#include <math.h>
#include <time.h>
#include <SFML/Graphics.hpp>
#include <iostream>
#include "Fluid.h"
#include "Particle.h"
#include "SpatialGrid.h"

#include <stdio.h>
#include <stdlib.h>

#include <algorithm>
#include <vector>

#include <GL/glew.h>

#include <GLFW/glfw3.h>
GLFWwindow* window;

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/norm.hpp>
using namespace glm;

#include "common/controls.hpp"
#include "common/shader.hpp"
#include "common/texture.hpp"

int mains(void) {
  // Initialise GLFW
  if (!glfwInit()) {
    fprintf(stderr, "Failed to initialize GLFW\n");
    getchar();
    return -1;
  }

  glfwWindowHint(GLFW_SAMPLES, 4);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,
                 GL_TRUE);  // To make MacOS happy; should not be needed
  glfwWindowHint(GLFW_OPENGL_PROFILE,
                 GLFW_OPENGL_CORE_PROFILE);  // We don't want the old OpenGL

  // Open a window and create its OpenGL context
  window = glfwCreateWindow(1024, 768, "Tutorial 03 - Matrices", NULL, NULL);
  if (window == NULL) {
    fprintf(stderr,
            "Failed to open GLFW window. If you have an Intel GPU, they are "
            "not 3.3 compatible. Try the 2.1 version of the tutorials.\n");
    getchar();
    glfwTerminate();
    return -1;
  }
  glfwMakeContextCurrent(window);

  // Initialize GLEW
  glewExperimental = true;  // Needed for core profile
  if (glewInit() != GLEW_OK) {
    fprintf(stderr, "Failed to initialize GLEW\n");
    getchar();
    glfwTerminate();
    return -1;
  }

  // Ensure we can capture the escape key being pressed below
  glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

  // Dark blue background
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

  GLuint BackgroundVertexArrayID;
  glGenVertexArrays(1, &BackgroundVertexArrayID);
  glBindVertexArray(BackgroundVertexArrayID);

  // Create and compile our GLSL program from the shaders
  GLuint backgroundID = LoadShaders("../shader/backgroundvertexshader.glsl",
                                    "../shader/backgroundfragmentshader.glsl");

  // Get a handle for our "MVP" uniform
  GLuint BackgroundMatrixID = glGetUniformLocation(backgroundID, "MVP");

  // Projection matrix : 45� Field of View, 4:3 ratio, display range : 0.1 unit
  // <-> 100 units
  glm::mat4 Projection =
      glm::perspective(glm::radians(45.0f), 4.0f / 3.0f, 0.1f, 100.0f);
  // Or, for an ortho camera :
  // glm::mat4 Projection = glm::ortho(-10.0f,10.0f,-10.0f,10.0f,0.0f,100.0f);
  // // In world coordinates

  // Camera matrix
  glm::mat4 View = glm::lookAt(
      glm::vec3(4, 3, 3),  // Camera is at (4,3,3), in World Space
      glm::vec3(0, 0, 0),  // and looks at the origin
      glm::vec3(0, 1, 0)   // Head is up (set to 0,-1,0 to look upside-down)
  );
  // Model matrix : an identity matrix (model will be at the origin)
  glm::mat4 Model = glm::mat4(1.0f);
  // Our ModelViewProjection : multiplication of our 3 matrices
  glm::mat4 MVP =
      Projection * View *
      Model;  // Remember, matrix multiplication is the other way around

  static const GLfloat g_background_vertex_buffer_data[] = {
      -10.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
  };

  GLuint backgroundvertexbuffer;
  glGenBuffers(1, &backgroundvertexbuffer);
  glBindBuffer(GL_ARRAY_BUFFER, backgroundvertexbuffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_background_vertex_buffer_data),
               g_background_vertex_buffer_data, GL_STATIC_DRAW);

  do {
    // Clear the screen
    glClear(GL_COLOR_BUFFER_BIT);

    // Use our shader
    glUseProgram(backgroundID);

    // Send our transformation to the currently bound shader,
    // in the "MVP" uniform
    glUniformMatrix4fv(BackgroundMatrixID, 1, GL_FALSE, &MVP[0][0]);

    // 1rst attribute buffer : vertices
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, backgroundvertexbuffer);
    glVertexAttribPointer(0,  // attribute. No particular reason for 0, but must
                              // match the layout in the shader.
                          3,  // size
                          GL_FLOAT,  // type
                          GL_FALSE,  // normalized?
                          0,         // stride
                          (void*)0   // array buffer offset
    );

    // Draw the triangle !
    glDrawArrays(GL_TRIANGLES, 0, 3);  // 3 indices starting at 0 -> 1 triangle

    glDisableVertexAttribArray(0);

    // Swap buffers
    glfwSwapBuffers(window);
    glfwPollEvents();

  }  // Check if the ESC key was pressed or the window was closed
  while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &&
         glfwWindowShouldClose(window) == 0);

  // Close OpenGL window and terminate GLFW
  glfwTerminate();

  return 0;
}

int main(void) {
  // simulation parameters
  const float dt = 0.01;
  const int MaxParticles = 2000;
  int n = MaxParticles;
  float kernel_radius = 4;

  // mouse coordinates
  glm::vec4 pos, prev_pos;

  // spawns a fluid with n with an assigned radius of effect
  Fluid Water(n, kernel_radius);

  // these arrays get used to render the particles in main function
  std::vector<float> render_x(n);
  std::vector<float> render_y(n);
  std::vector<sf::Color> render_col(n);

  // creates a renderwindow
  if (!glfwInit()) {
    fprintf(stderr, "Failed to initialize GLFW\n");
    getchar();
    return -1;
  }
  glfwWindowHint(GLFW_SAMPLES, 4);
  glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,
                 GL_TRUE);  // To make MacOS happy; should not be needed
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  // Open a window and create its OpenGL context
  window = glfwCreateWindow(1024, 768, "Tutorial 18 - Particules", NULL, NULL);
  if (window == NULL) {
    fprintf(stderr,
            "Failed to open GLFW window. If you have an Intel GPU, they are "
            "not 3.3 compatible. Try the 2.1 version of the tutorials.\n");
    getchar();
    glfwTerminate();
    return -1;
  }
  glfwMakeContextCurrent(window);

  // Initialize GLEW
  glewExperimental = true;  // Needed for core profile
  if (glewInit() != GLEW_OK) {
    fprintf(stderr, "Failed to initialize GLEW\n");
    getchar();
    glfwTerminate();
    return -1;
  }

  // Ensure we can capture the escape key being pressed below
  glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

  // Black Background background
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

  // Enable depth test
  glEnable(GL_DEPTH_TEST);

  // Accept fragment if it closer to the camera than the former one
  glDepthFunc(GL_LESS);

  GLuint VertexArrayID;
  glGenVertexArrays(1, &VertexArrayID);
  glBindVertexArray(VertexArrayID);

  // Create and compile our GLSL program from the shaders
  GLuint programID = LoadShaders("../shader/particlevertexshader.glsl",
                                 "../shader/particlefragmentshader.glsl");

  // Vertex shader
  GLuint CameraRight_worldspace_ID =
      glGetUniformLocation(programID, "CameraRight_worldspace");
  GLuint CameraUp_worldspace_ID =
      glGetUniformLocation(programID, "CameraUp_worldspace");
  GLuint ViewProjMatrixID = glGetUniformLocation(programID, "VP");

  // fragment shader
  GLuint TextureID = glGetUniformLocation(programID, "myTextureSampler");

  static GLfloat* g_particule_position_size_data =
      new GLfloat[MaxParticles * 4];
  static GLubyte* g_particule_color_data = new GLubyte[MaxParticles * 4];

  GLuint Texture = loadDDS("../shader/particle.DDS");

  // The VBO containing the 4 vertices of the particles.
  // Thanks to instancing, they will be shared by all particles.
  static const GLfloat g_vertex_buffer_data[] = {
      -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f,
      -0.5f, 0.5f,  0.0f, 0.5f, 0.5f,  0.0f,
  };

  GLuint billboard_vertex_buffer;
  glGenBuffers(1, &billboard_vertex_buffer);
  glBindBuffer(GL_ARRAY_BUFFER, billboard_vertex_buffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data),
               g_vertex_buffer_data, GL_STATIC_DRAW);

  // The VBO containing the positions and sizes of the particles
  GLuint particles_position_buffer;
  glGenBuffers(1, &particles_position_buffer);
  glBindBuffer(GL_ARRAY_BUFFER, particles_position_buffer);
  // Initialize with empty (NULL) buffer : it will be updated later, each frame.
  glBufferData(GL_ARRAY_BUFFER, MaxParticles * 4 * sizeof(GLfloat), NULL,
               GL_STREAM_DRAW);

  // The VBO containing the colors of the particles
  GLuint particles_color_buffer;
  glGenBuffers(1, &particles_color_buffer);
  glBindBuffer(GL_ARRAY_BUFFER, particles_color_buffer);
  // Initialize with empty (NULL) buffer : it will be updated later, each frame.
  glBufferData(GL_ARRAY_BUFFER, MaxParticles * 4 * sizeof(GLubyte), NULL,
               GL_STREAM_DRAW);

  GLuint BackgroundVertexArrayID;
  glGenVertexArrays(1, &BackgroundVertexArrayID);
  glBindVertexArray(BackgroundVertexArrayID);

  GLuint backgroundID = LoadShaders("../shader/backgroundvertexshader.glsl",
                                    "../shader/backgroundfragmentshader.glsl");

  // Get a handle for our "MVP" uniform
  GLuint BackgroundMatrixID = glGetUniformLocation(backgroundID, "MVP");

  // Projection matrix : 45� Field of View, 4:3 ratio, display range : 0.1 unit
  // <-> 100 units
  glm::mat4 Projection =
      glm::perspective(glm::radians(45.0f), 4.0f / 3.0f, 0.1f, 100.0f);
  // Or, for an ortho camera :
  // glm::mat4 Projection = glm::ortho(-10.0f,10.0f,-10.0f,10.0f,0.0f,100.0f);
  // // In world coordinates

  // Camera matrix
  glm::mat4 View = glm::lookAt(
      glm::vec3(4, 3, 3),  // Camera is at (4,3,3), in World Space
      glm::vec3(0, 0, 0),  // and looks at the origin
      glm::vec3(0, 1, 0)   // Head is up (set to 0,-1,0 to look upside-down)
  );
  // Model matrix : an identity matrix (model will be at the origin)
  glm::mat4 Model = glm::mat4(1.0f);
  // Our ModelViewProjection : multiplication of our 3 matrices
  glm::mat4 MVP =
      Projection * View *
      Model;  // Remember, matrix multiplication is the other way around

  static const GLfloat g_background_vertex_buffer_data[] = {
      0.0f,   0.0f,    -1.1f, 150.0f, 0.0f, -1.1f, 0.0f, -190.0f, -1.1f,
      150.0f, -190.0f, -1.1f, 150.0f, 0.0f, -1.1f, 0.0f, -190.0f, -1.1f,
  };

  GLuint backgroundvertexbuffer;
  glGenBuffers(1, &backgroundvertexbuffer);
  glBindBuffer(GL_ARRAY_BUFFER, backgroundvertexbuffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_background_vertex_buffer_data),
               g_background_vertex_buffer_data, GL_STATIC_DRAW);

  do {
    // Clear the screen
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    computeMatricesFromInputs();
    glm::mat4 ProjectionMatrix = getProjectionMatrix();
    glm::mat4 ViewMatrix = getViewMatrix();
    glm::mat4 ModelMatrix = glm::mat4();

    // We will need the camera's position in order to sort the particles
    // w.r.t the camera's distance.
    // There should be a getCameraPosition() function in common/controls.cpp,
    // but this works too.
    glm::vec3 CameraPosition(glm::inverse(ViewMatrix)[3]);
    glm::mat4 ViewProjectionMatrix = ProjectionMatrix * ViewMatrix;

    // simulate
    Water.update(dt);

    // now draw the particles
    Water.getCoordinates(render_x, render_y);
    Water.getCol(render_col);

    // Simulate all particles
    int ParticlesCount = 0;
    for (int i = 0; i < n; i++) {
      // Fill the GPU buffer
      g_particule_position_size_data[4 * ParticlesCount + 0] = render_x[i];
      g_particule_position_size_data[4 * ParticlesCount + 1] = -render_y[i];
      g_particule_position_size_data[4 * ParticlesCount + 2] = 0;

      g_particule_position_size_data[4 * ParticlesCount + 3] = 1.5;

      g_particule_color_data[4 * ParticlesCount + 0] = 0;
      g_particule_color_data[4 * ParticlesCount + 1] = 100;
      g_particule_color_data[4 * ParticlesCount + 2] = 255;
      g_particule_color_data[4 * ParticlesCount + 3] = 255;

      ParticlesCount++;
    }

    glDisable(GL_BLEND);

    // Use our container shader
    glUseProgram(backgroundID);

    // mouse controls magic...not super elegant or understandable but it somehow
    // works :)
    glm::vec4 test_particle(0, 0, 0, 1);
    glm::vec4 test_result = ViewProjectionMatrix * test_particle;
    prev_pos = pos;
    double xpos, ypos;
    double mx, my;
    glfwGetCursorPos(window, &xpos, &ypos);
    xpos = 2 * (xpos / 1024) - 1;
    ypos = 2 * (ypos / 768) - 1;
    pos.x = xpos * test_result[3];
    pos.y = -ypos * test_result[3];
    pos.z = test_result[2];
    pos.w = 1 * test_result[3];
    pos = glm::inverse(ViewProjectionMatrix) * pos;

    // now these calculated coordinates are real world...but y is flipped lol,
    // so I solve that here
    Water.mousePush(pos.x, -pos.y, 10 * (pos.x - prev_pos.x),
                    10 * (-pos.y + prev_pos.y));

    glUniformMatrix4fv(BackgroundMatrixID, 1, GL_FALSE,
                       &ViewProjectionMatrix[0][0]);

    // 1rst attribute buffer : vertices
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, backgroundvertexbuffer);
    glVertexAttribPointer(0,  // attribute. No particular reason for 0, but must
                              // match the layout in the shader.
                          3,  // size
                          GL_FLOAT,  // type
                          GL_FALSE,  // normalized?
                          0,         // stride
                          (void*)0   // array buffer offset
    );

    // Draw the triangle !
    glDrawArrays(GL_TRIANGLES, 0, 6);  // 6 indices starting at 0 -> 1 triangle

    glDisableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, particles_position_buffer);
    glBufferData(
        GL_ARRAY_BUFFER, MaxParticles * 4 * sizeof(GLfloat), NULL,
        GL_STREAM_DRAW);  // Buffer orphaning, a common way to improve streaming
                          // perf. See above link for details.
    glBufferSubData(GL_ARRAY_BUFFER, 0, ParticlesCount * sizeof(GLfloat) * 4,
                    g_particule_position_size_data);

    glBindBuffer(GL_ARRAY_BUFFER, particles_color_buffer);
    glBufferData(
        GL_ARRAY_BUFFER, MaxParticles * 4 * sizeof(GLubyte), NULL,
        GL_STREAM_DRAW);  // Buffer orphaning, a common way to improve streaming
                          // perf. See above link for details.
    glBufferSubData(GL_ARRAY_BUFFER, 0, ParticlesCount * sizeof(GLubyte) * 4,
                    g_particule_color_data);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Use our shader
    glUseProgram(programID);

    // Bind our texture in Texture Unit 0
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, Texture);

    // Set our "myTextureSampler" sampler to use Texture Unit 0
    glUniform1i(TextureID, 0);

    // Same as the billboards tutorial
    glUniform3f(CameraRight_worldspace_ID, ViewMatrix[0][0], ViewMatrix[1][0],
                ViewMatrix[2][0]);
    glUniform3f(CameraUp_worldspace_ID, ViewMatrix[0][1], ViewMatrix[1][1],
                ViewMatrix[2][1]);

    glUniformMatrix4fv(ViewProjMatrixID, 1, GL_FALSE,
                       &ViewProjectionMatrix[0][0]);

    // 1rst attribute buffer : vertices
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, billboard_vertex_buffer);
    glVertexAttribPointer(0,  // attribute. No particular reason for 0, but must
                              // match the layout in the shader.
                          3,  // size
                          GL_FLOAT,  // type
                          GL_FALSE,  // normalized?
                          0,         // stride
                          (void*)0   // array buffer offset
    );

    // 2nd attribute buffer : positions of particles' centers
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, particles_position_buffer);
    glVertexAttribPointer(1,  // attribute. No particular reason for 1, but must
                              // match the layout in the shader.
                          4,  // size : x + y + z + size => 4
                          GL_FLOAT,  // type
                          GL_FALSE,  // normalized?
                          0,         // stride
                          (void*)0   // array buffer offset
    );

    // 3rd attribute buffer : particles' colors
    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, particles_color_buffer);
    glVertexAttribPointer(2,  // attribute. No particular reason for 1, but must
                              // match the layout in the shader.
                          4,  // size : r + g + b + a => 4
                          GL_UNSIGNED_BYTE,  // type
                          GL_TRUE,  // normalized?    *** YES, this means that
                                    // the unsigned char[4] will be accessible
                                    // with a vec4 (floats) in the shader ***
                          0,        // stride
                          (void*)0  // array buffer offset
    );

    // These functions are specific to glDrawArrays*Instanced*.
    // The first parameter is the attribute buffer we're talking about.
    // The second parameter is the "rate at which generic vertex attributes
    // advance when rendering multiple instances"
    // http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttribDivisor.xml
    glVertexAttribDivisor(
        0, 0);  // particles vertices : always reuse the same 4 vertices -> 0
    glVertexAttribDivisor(1, 1);  // positions : one per quad (its center) -> 1
    glVertexAttribDivisor(2, 1);  // color : one per quad -> 1

    // Draw the particules !
    // This draws many times a small triangle_strip (which looks like a quad).
    // This is equivalent to :
    // for(i in ParticlesCount) : glDrawArrays(GL_TRIANGLE_STRIP, 0, 4),
    // but faster.
    glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, ParticlesCount);
    // glDrawArrays(GL_TRIANGLES, 5, 7);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);

    // Swap buffers
    glfwSwapBuffers(window);
    glfwPollEvents();

  }  // Check if the ESC key was pressed or the window was closed
  while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &&
         glfwWindowShouldClose(window) == 0);

  delete[] g_particule_position_size_data;

  // Cleanup VBO and shader
  glDeleteBuffers(1, &particles_color_buffer);
  glDeleteBuffers(1, &particles_position_buffer);
  glDeleteBuffers(1, &billboard_vertex_buffer);
  glDeleteProgram(programID);
  glDeleteTextures(1, &Texture);
  glDeleteVertexArrays(1, &VertexArrayID);

  // Cleanup VBO and shader
  glDeleteBuffers(1, &backgroundvertexbuffer);
  glDeleteProgram(backgroundID);
  glDeleteVertexArrays(1, &BackgroundVertexArrayID);

  // Close OpenGL window and terminate GLFW
  glfwTerminate();

  return 0;
}
